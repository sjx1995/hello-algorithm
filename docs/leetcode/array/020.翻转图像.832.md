# 翻转图像（832）

## 题目 

给定一个二进制矩阵 `A`，我们想先`水平翻转图像`，然后`反转图像`并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。

反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。

## 示例

输入: `[[1,1,0],[1,0,1],[0,0,0]]`
输出: `[[1,0,0],[0,1,0],[1,1,1]]`
解释: 首先翻转每一行: `[[0,1,1],[1,0,1],[0,0,0]]`；
      然后反转图片: `[[1,0,0],[0,1,0],[1,1,1]]`
示例 2:

输入: `[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]`
输出: `[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]`
解释: 首先翻转每一行: `[[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]`；
      然后反转图片: `[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]`

## 说明:

`1 <= A.length = A[0].length <= 20`
`0 <= A[i][j] <= 1`

## 算法

### 方法一

```js
export const flipAndInvertImage = (A) => {
	return A.map((row) => row.reverse().map((rowEle) => +!rowEle));
};
```

### 方法二

观察转换方法可发现，`a[i][j]`和`a[i][a[0].length-j]`先交换后各自取反：
如果两个数为`1和0`或`0和1`，转换后（先交换后取反）仍为原值；
如果两个数均为`1`或`0`，那么他们均为原值的相反数（这里可以用`1`与其进行异或运算：`1^1===0`、`1^0===1`）

最后在循环完一列后，如果列中元素个数为奇数，则需要对最中间的数字进行取反

```js
export const flipAndInvertImage = (A) => {
	for (let i = 0; i < A.length; i++) {
		let l = 0,
			r = A[0].length - 1;
		while (l < r) {
			if (A[i][l] === A[i][r]) {
				A[i][l] = 1 ^ A[i][l];
				A[i][r] = 1 ^ A[i][r];
			}
			l++;
			r--;
		}
		if (l === r) {
			A[i][l] = 1 ^ A[i][l];
		}
	}
	return A;
};
```