# 找出数组游戏的赢家（1535）

## 题目

给你一个由 不同 整数组成的整数数组 arr 和一个整数 k 。

每回合游戏都在数组的前两个元素（即 arr[0] 和 arr[1] ）之间进行。比较 arr[0] 与 arr[1] 的大小，较大的整数将会取得这一回合的胜利并保留在位置 0 ，较小的整数移至数组的末尾。当一个整数赢得 k 个连续回合时，游戏结束，该整数就是比赛的 赢家 。

返回赢得比赛的整数。

题目数据 保证 游戏存在赢家。

## 示例

输入：`arr = [2,1,3,5,4,6,7]`, `k = 2`
输出：`5`

输入：`arr = [3,2,1]`, `k = 10`
输出：`3`

输入：`arr = [1,9,8,2,3,7,6,4,5]`, `k = 7`
输出：`9`

输入：`arr = [1,11,22,33,44,55,66,77,88,99]`, `k = 1000000000`
输出：`99`
 

## 提示

- 2 <= arr.length <= 10^5
- 1 <= arr[i] <= 10^6
- arr 所含的整数 各不相同 。
- 1 <= k <= 10^9

## 算法

明确两点：

- 当`k`很大时，只要找出数组最大的数，即是结果
- 当一个数字`x`打败`y`时，同时他也会打败之前被`y`打败的数字

模拟过程：

- 当前连胜的数字下标`resIndex`，遍历数组的指针`i`，当前连胜的次数`winCount`
- 开始默认的`resIndex`为0，指针指向的第二个位置即`1`
- 指针`i`向后遍历，如果`arr[resIndex]`比他大，则让连胜次数+1；否则将第`i`个位置赋给`resIndex`，此时因为这个新的位置的数已经在这轮比赛中获胜，所以重置`winCount`应为`1`而不是0
- 每一轮循环后比较当前`winCount`是否满足了连胜`k`次的要求，如果满足返回当前连胜的`arr[resIndex]`
- 如果遍历整个数组后还没有满足连胜`k`的要求，那么此时的`arr[resIndex]`一定比其余所有数字大，所以返回`arr[resIndex]`即可

```js
export const getWinner = (arr, k) => {
	let resIndex = 0;
	let winCount = 0;
	for (let i = 1; i < arr.length; i++) {
		if (arr[resIndex] > arr[i]) {
			winCount++;
		} else {
			resIndex = i;
			winCount = 1;
		}
		if (winCount >= k) {
			return arr[resIndex];
		}
	}
	return arr[resIndex];
};
```