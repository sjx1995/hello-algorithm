# 非递增顺序的最小子序列（1403）

## 题目

给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 **严格** 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。

与子数组不同的地方在于，**「数组的子序列」**不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

注意，题目数据保证满足所有约束条件的解决方案是 `唯一` 的。同时，返回的答案应当按 `非递增顺序` 排列。

## 示例

输入：`nums = [4,3,10,9,8]`
输出：`[10,9]`
> 解释：子序列 `[10,9]` 和 `[10,8]` 是最小的、满足元素之和大于其他各元素之和的子序列。但是 `[10,9]` 的元素之和最大。 

输入：`nums = [4,4,7,6,7]`
输出：`[7,7,6]` 

输入：`nums = [6]`
输出：`[6]`

## 提示

- 1 <= nums.length <= 500
- 1 <= nums[i] <= 100

## 算法

### 贪心

求`长度最小`且`和最大`的满足条件的子序列，所以我们要尽量让满足条件的话，可以先将数组**由大到小**排序，然后取最前面的`n`个元素使其和大于其余元素的和。

因为我们取了最大的`n`个元素，所以满足`和最大`，而且当最大的前`n`个元素不满足时，之后的元素（如`2,3,4,...,n+1`）也不会满足，所以可以不考虑。

因为我们依次取前`n`个元素，所以子序列的长度是递增的，当满足条件时，此时的子序列一定是`长度最小的`

```js
export const minSubsequence = (nums) => {
	nums.sort((a, b) => b - a);
	let sum = nums.reduce((acc, cur) => (acc += cur));
	let minSum = 0;
	const res = [];
	for (let i = 0; i < nums.length; i++) {
		minSum += nums[i];
		res.push(nums[i]);
		if (minSum > sum - minSum) break;
	}
	return res;
};
```