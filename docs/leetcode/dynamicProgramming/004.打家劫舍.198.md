# 打家劫舍（198）

## 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的**最高金额**。

## 示例

输入：`[1,2,3,1]`
输出：`4`
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。

输入：`[2,7,9,3,1]`
输出：`12`
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。

## 提示

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 400

## 算法

### 动态规划

当没有房子时，偷盗的金额为`0`

当只有一间房子时，偷盗的金额为`nums[0]`

当有两间房子时，偷盗的金额是两间房子中的较大值

所以问题的关键是大于等于三间房子的情况：

当偷盗第`n`间屋子时，最多的偷盗方式是`nums[n] + nums[n-2]`和`nums[n-1]`中的较大值

所以我们使用数组`money`来保存偷盗第`n`间屋子时偷盗的最多金额，`money`数组初始化前两项等于`nums`的前两项，从第三项开始选择`money[n-2]+nums[n]`和`money[n-1]`中的较大值赋值给`money[n]`

最后偷盗的最大金额就是`money`数组的最后一项

```js
const rob = nums => {
	if (nums.length === 0) return 0;
	if (nums.length <= 2) return Math.max(...nums);
	let money = [nums[0], Math.max(nums[0], nums[1])];
	for (let i = 2; i < nums.length; i++) {
		money[i] = Math.max(money[i - 2] + nums[i], money[i - 1]);
	}
	return money[money.length - 1];
};
```